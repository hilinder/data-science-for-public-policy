---
title: "chapter 1"
author: "Harrison Linder"
date: "`r Sys.Date()`"
output: html_document
---

below are the necessary libraries to use for this course

```{r}
library(tidyverse)
library(tidycensus)
library(sf)
library(kableExtra)

options(scipen=999)
options(tigris_class = "sf")

# the below line was changed from the code provided in the book. the operator giver was "=", however that appeared to not save "root.dir" to the environment, so I chaged the operator to "<-"

root.dir <- "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")
```

Here is the color palette we are going to use for maps
```{r}
palette5 <- c("#f0f9e8","#bae4bc","#7bccc4","#43a2ca","#0868ac")

```

how to install my census api key
```{r}
census_api_key("c08e727b3d32b823955aea424744c9dda3b30df0", install = TRUE, overwrite = TRUE)
# readRenviron("~/.Renviron") is for some reason needed for the api to be active in the current session 
readRenviron("~/.Renviron")
```
we will be using the following data

from the textbook: In this chapter, the tidycensus is used to query and return Census data directly into R. At the time of publication however, the Census has disabled the year 2000 endpoint/data.10 Instead, the code below downloads an equivalent data frame called tracts00. A data frame is the most common way to store data in R. The code block at the end of this section demonstrates a tidycensus call to return 2017 data.
```{r}
tracts00 <- 
  st_read(file.path(root.dir,"/Chapter1/PHL_CT00.geojson")) %>% 
    st_transform('ESRI:102728')

tracts00[1:3,]
```
to find out how many census plots we have in our geography (Philadelphia), we can create a table the displays how many rows we have by variable. our data is long formatted so there are multiple rows representing a given census plot.
```{r}
table(tracts00$variable)
```
now we are going to plot population by census plot in the year 2000. To do that, we are going to create a variable the has filtered for only rows where the variable is that representing population in the year 2000. 
```{r}
totalpop00 <- 
    tracts00 %>%
    filter(variable == "P001001")
#lets make sure we have the correct number of rows (381)
nrow(totalpop00)    
# lets see a snapshot of our data
head(totalpop00)
```
lets take a look at what the basic "plot function does for an {sf} layer

```{r}
plot(totalpop00)
```

### the textbook illustrates how to make progressively more useful maps using the ggplot function with geom_sf layers

from the textbook:
A maps totalPop00, using the aes or aesthetic parameter to fill the tract polygons by the value field.

Plot B converts value to 5 quintile categories using the q5 function. These 5 categories are of class factor. Try q5(totalPop00$value).

Plot C adds fill color and legend improvements using the scale_fill_manual function. Many different scale types are possible.13 values is set to a list of colors, palette5. labels is set to the values of the associated quintiles (try qBr(totalPop00, "value")). Finally, a legend name is added. \n inserts a hard return.

Plot D inserts a title using the labs parameter, as well as a mapTheme

```{r}
Plot_A <- 
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = value))

Plot_B <- 
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = q5(value)))

Plot_C <-
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = q5(value))) +
  scale_fill_manual(values = palette5,
                    labels = qBr(totalpop00, "value"),
                    name = "Total\nPopluation\n(Quintile Breaks)")

Plot_D <- 
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = q5(value))) +
  scale_fill_manual(values = palette5,
                    labels = qBr(totalpop00, "value"),
                    name = "Popluation\n(Quintile Breaks)") +
  labs(title = "Total Population", subtitle = "Philadelphia; 2000") +
  mapTheme()
```
the above code saves our plots to their assigned variables. below we can print them.

```{r}
print(Plot_A)
print(Plot_B)
print(Plot_C)
print(Plot_D)
```
next, the textbook converts the data from long format to wide format and in general makes it easier to read.
```{r}
tracts00 <- 
  dplyr::select(tracts00, -NAME) %>%
    spread(variable, value) %>%
    dplyr::select(-geometry) %>%
    rename(TotalPop = P001001, Whites = P006002, MaleBachelors = PCT025009,
           FemaleBachelors = PCT025050, MedHHInc = P053001, MedRent = H056001,
           TotalPoverty = P092001) 

st_drop_geometry(tracts00)[1:3,]
```
lets change our data to wide format 
```{r}
tracts00 <- 
  tracts00 %>%
  mutate(pctWhite = ifelse(TotalPop > 0, Whites / TotalPop, 0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop), 0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2000") %>%
  dplyr::select(-Whites,-FemaleBachelors,-MaleBachelors,-TotalPoverty)
```

now we are going to query 2017 acs data to match our 2000 data. I am going to change the code from the textbook so that we can see the data change which each line of code.
```{r}
tracts17 <- 
  get_acs(geography = "tract", variables = c("B25026_001E","B02001_002E","B15001_050E",
                                             "B15001_009E","B19013_001E","B25058_001E",
                                             "B06012_002E"), 
          year=2017, state=42, county=101, geometry=T, output="wide") %>%
    #the above code specifies the query from the census API, note that more than just the specified variables are generated as columns. I'm not sure what the additional variables represent.
    print() %>%
  st_transform('ESRI:102728') %>%
    # changes the CRS to what we have been using
    print() %>%
  rename(TotalPop = B25026_001E, Whites = B02001_002E,
         FemaleBachelors = B15001_050E, MaleBachelors = B15001_009E,
         MedHHInc = B19013_001E, MedRent = B25058_001E,
         TotalPoverty = B06012_002E) %>%
    #names our columns 
    print() %>%
  dplyr::select(-NAME, -starts_with("B")) %>%
    #removes names and all the columns that start with "b". all the variable codes start with b, so any columns that we didnt name get deleted
    print() %>%
  mutate(pctWhite = ifelse(TotalPop > 0, Whites / TotalPop,0),
         pctBachelors = ifelse(TotalPop > 0, ((FemaleBachelors + MaleBachelors) / TotalPop),0),
         pctPoverty = ifelse(TotalPop > 0, TotalPoverty / TotalPop, 0),
         year = "2017") %>%
    #calculates our statistics of interest as a rate instead of a count. we use ifelse functions to account for cases in which we have 0 numerator or denominator. that could be a result of incomplete data.
    print() %>%
  dplyr::select(-Whites, -FemaleBachelors, -MaleBachelors, -TotalPoverty) 
    #removes the selected columns. the - operator specifies that we want everything besides the specified columns
head(tracts17)
```
now we are going to combine our two data sets, one from 2000, one from 2017, together
```{r}
allTracts <- rbind(tracts00,tracts17)
```
## philly transit open data
from the textbook: The code below downloads and binds together El and Broad St. station locations into a single layer, septaStops. st_read downloads the data in geojson form (with geometries) from the web. A Line field is generated and selected along with the Station field. Lastly, the data is projected into the same coordinate system as tracts00.
```{r}
septaStops <- 
  rbind(
    st_read("https://opendata.arcgis.com/datasets/8c6e2575c8ad46eb887e6bb35825e1a6_0.geojson") %>% 
    mutate(Line = "El") %>% #this line adds the label 'El' to a newly created "Line" Column 
    select(Station, Line),
      st_read("https://opendata.arcgis.com/datasets/2e9037fd5bef406488ffe5bb67d21312_0.geojson") %>%
      mutate(Line ="Broad_St") %>%
      select(Station, Line)) %>%
   st_transform(st_crs(tracts00))  #note how you can call the crs from the tracts00 dataframe using str_crs
```
lets map our stops onto the city
```{r}
ggplot() + #creates the plot
  geom_sf(data=st_union(tracts00)) + #adds the dissolved tract boundaries city map as a layer
  geom_sf(data=septaStops, aes(colour = Line), show.legend = "point", size= 2) + # adds the septaStops as a layer to the map with different colors for each of the values in the Line column
  scale_colour_manual(values = c("orange","blue")) +
  labs(title="Septa Stops", subtitle="Philadelphia, PA") +
  mapTheme()
```


now we are going to create "buffer" areas around each stop to be considered as transit oriented areas
```{r}
septaBuffers <- 
  rbind(
    st_buffer(septaStops, 2640) %>% # creates the buffers of 2640 feet (1/2 mile).
      mutate(Legend = "Buffer") %>% # creates legend column with a buffer label for each stop buffer
      dplyr::select(Legend), #selects only the legend column along with the geometry to remain in the dataframe
    st_union(st_buffer(septaStops, 2640)) %>% 
      st_sf() %>% #this function is for some reason needed to convert the union transit areas created with the last line into an sf layer
      mutate(Legend = "Unioned Buffer"))

ggplot() +
  geom_sf(data=septaBuffers) +
  geom_sf(data=septaStops, show.legend = "point") +
  facet_wrap(~Legend) + #facet wrap can only be performed on long data
  mapTheme()
```

now we need to select which tracts constitute part of the trasit oriented area. there are three methods that the book discusses for selecting tracts. The first is clipping, which selects the interesections of the tract and the buffer. This is problematic because the data for each tract aligns with the whole tract and its unclear how the clipping method divides the other variables if at all after subtracting area.
```{r}
buffer <- filter(septaBuffers, Legend=="Unioned Buffer")

clip <- 
  st_intersection(buffer, tracts00) %>%
    dplyr::select(TotalPop) %>%
    mutate(Selection_Type = "Clip")
```

the next method is to select any geometries that intersect with the buffer
```{r}
selection <- 
  tracts00[buffer,] %>%
    dplyr::select(TotalPop) %>%
    mutate(Selection_Type = "Spatial Selection")
```

and the last method is to choose all tracts of which's "center of gravity" fall within the buffer. you imigane the ceter of gravity as at what point you would need to put your finger to balance the shape atop of it. This is the preffered method of the author.
```{r}
selectCentroids <-
  st_centroid(tracts00)[buffer,] %>% #creates centroid point geometry for tracts whose centroid is within the buffer
print() %>%
    st_drop_geometry() %>% #this converts the sf into a dataframe to allow for it to be joined back with the original sf. I think that this is necessary because there cannot be more than one geometry per row in an sf
print() %>%
    left_join(dplyr::select(tracts00, GEOID)) %>% #this joins the two data frames by the unique geoids. so it seems that since our centroid frame is the first variable, we get only matches that exist from that frame. and what we are matching it to is only the GEOID from tracts00. since tracts is a sf it seems like you are unable to select away the geometry
print() %>%
    st_sf() %>% # converts dataframe back to sf
    dplyr::select(TotalPop) %>% #for some reason we only want total population
    mutate(Selection_Type = "Select by Centroids") #creates the select by centroids value in the Selection_type column. this will be useful for the side by side map we are going to create
print(selectCentroids)
```
now the textbook challenges us to create a side by side maps of the various selection types using the facet_wrap layer tool from earlier
```{r}
all_types_tracts00 <-
    rbind(clip,selection,selectCentroids)

ggplot() + #creates the plot
  geom_sf(data=st_union(tracts00)) + #creates our city outline
     geom_sf(data = all_types_tracts00, aes(fill = q5(TotalPop))) +
  scale_fill_manual(values = palette5,
                    labels = qBr(all_types_tracts00, "TotalPop"),
                    name = "Popluation\n(Quintile Breaks)") +
  labs(title = "Total Population", subtitle = "Philadelphia; 2000") +
facet_wrap(~Selection_Type) +
  mapTheme()
```

