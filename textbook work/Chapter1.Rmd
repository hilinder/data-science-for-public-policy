---
title: "chapter 1"
author: "Harrison Linder"
date: "`r Sys.Date()`"
output: html_document
---

below are the necessary libraries to use for this course

```{r}
library(tidyverse)
library(tidycensus)
library(sf)
library(kableExtra)

options(scipen=999)
options(tigris_class = "sf")

# the below line was changed from the code provided in the book. the operator giver was "=", however that appeared to not save "root.dir" to the environment, so I chaged the operator to "<-"

root.dir <- "https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/"
source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")
```

Here is the color palette we are going to use for maps
```{r}
palette5 <- c("#f0f9e8","#bae4bc","#7bccc4","#43a2ca","#0868ac")

```

how to install my census api key
```{r}
census_api_key("c08e727b3d32b823955aea424744c9dda3b30df0", install = TRUE, overwrite = TRUE)
# readRenviron("~/.Renviron") is for some reason needed for the api to be active in the current session 
readRenviron("~/.Renviron")
```
we will be using the following data

from the textbook: In this chapter, the tidycensus is used to query and return Census data directly into R. At the time of publication however, the Census has disabled the year 2000 endpoint/data.10 Instead, the code below downloads an equivalent data frame called tracts00. A data frame is the most common way to store data in R. The code block at the end of this section demonstrates a tidycensus call to return 2017 data.
```{r}
tracts00 <- 
  st_read(file.path(root.dir,"/Chapter1/PHL_CT00.geojson")) %>% 
    st_transform('ESRI:102728')

tracts00[1:3,]
```
to find out how many census plots we have in our geography (Philadelphia), we can create a table the displays how many rows we have by variable. our data is long formatted so there are multiple rows representing a given census plot.
```{r}
table(tracts00$variable)
```
now we are going to plot population by census plot in the year 2000. To do that, we are going to create a variable the has filtered for only rows where the variable is that representing population in the year 2000. 
```{r}
totalpop00 <- 
    tracts00 %>%
    filter(variable == "P001001")
#lets make sure we have the correct number of rows (381)
nrow(totalpop00)    
# lets see a snapshot of our data
head(totalpop00)
```
lets take a look at what the basic "plot function does for an {sf} layer

```{r}
plot(totalpop00)
```

### the textbook illustrates how to make progressively more useful maps using the ggplot function with geom_sf layers

from the textbook:
A maps totalPop00, using the aes or aesthetic parameter to fill the tract polygons by the value field.

Plot B converts value to 5 quintile categories using the q5 function. These 5 categories are of class factor. Try q5(totalPop00$value).

Plot C adds fill color and legend improvements using the scale_fill_manual function. Many different scale types are possible.13 values is set to a list of colors, palette5. labels is set to the values of the associated quintiles (try qBr(totalPop00, "value")). Finally, a legend name is added. \n inserts a hard return.

Plot D inserts a title using the labs parameter, as well as a mapTheme

```{r}
Plot_A <- 
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = value))

Plot_B <- 
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = q5(value)))

Plot_C <-
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = q5(value))) +
  scale_fill_manual(values = palette5,
                    labels = qBr(totalpop00, "value"),
                    name = "Total\nPopluation\n(Quintile Breaks)")

Plot_D <- 
  ggplot() +
  geom_sf(data = totalpop00, aes(fill = q5(value))) +
  scale_fill_manual(values = palette5,
                    labels = qBr(totalpop00, "value"),
                    name = "Popluation\n(Quintile Breaks)") +
  labs(title = "Total Population", subtitle = "Philadelphia; 2000") +
  mapTheme()
```
the above code saves our plots to their assigned variables. below we can print them.

```{r}
print(Plot_A)
print(Plot_B)
print(Plot_C)
print(Plot_D)
```
next, the textbook converts the data from long format to wide format and in general makes it easier to read.
```{r}
tracts00 <- 
  dplyr::select(tracts00, -NAME) %>%
    spread(variable, value) %>%
    dplyr::select(-geometry) %>%
    rename(TotalPop = P001001, Whites = P006002, MaleBachelors = PCT025009,
           FemaleBachelors = PCT025050, MedHHInc = P053001, MedRent = H056001,
           TotalPoverty = P092001) 

st_drop_geometry(tracts00)[1:3,]
```


